#' Detect trends and quantify their effect on the probability of SPEI values occurring
#'
#' @param PPE.at.TS
#' A 4-column matrix generated as generated by `PPESaggreg()`. No other objects are accepted.
#'  * 1st column is years (YYYY),
#'  * 2nd is the months (1 to 12),
#'  * 3rd is the quasiWeeks (1 to 4),
#'  * and 4th is the difference between P and PE accumulated at a time scale.
#' @param nonstat.models
#' A single integer number indicating the number of increasingly complex candidate
#' nonstationary models to be considered in the drought assessments (from 1 to 5).
#' If 1, only stationary and nonstationary (linear) in location models are fitted (2 candidates).
#' If 2, a nonstationary (linear) in scale model is included (3 candidates).
#' If 3, a nonstationary (linear) in both location and scale models is included (4 candidates).
#' Default is 1.
#' @param criterion
#' A character string value (`AICc` or `BIC`) defining the selection model criterion.
#' Second-order Akaike Information criterion (`AICc`) or Bayesian information criterion (`BIC`).
#' Default is `BIC`.
#' @returns
#' A `list` object with:
#' \describe{
#'   \item{data.week}{The P - PE amounts, SPEI, cumulative probability of the SPEI values under the stationary
#'   approach, cumulative probability of the SPEI values under the non-stationary approach,
#'   and the changes in the frequency of below zero SPEI values caused by the changes in P - PE patterns.}
#'   \item{Changes.Freq.Drought}{The non-stationary  GEV-based model that best fits the P - PE series,
#'    the expected P - PE amounts describing normal conditions under both stationary and non-stationary
#'    approaches, and the changes in the frequency of moderate to extreme, severe to extreme and extreme drought events}
#'    \item{GEV.parameters}{Parameters of the best fitting GEV model (location, scale and shape) for each quasi-week.}
#'  }
#' @examples #If interactive()
#' daily.PPE <- Campinas[, 11]
#' PPE.at.TS <- PPEaggreg(daily.PPE, start.date = "1995-01-01", TS = 4)
#' Changes_SPEI <- SPEIChanges(PPE.at.TS=PPE.at.TS, nonstat.models = 1)
#' @importFrom extRemes pevd qevd
#' @importFrom ismev gev.fit
#' @importFrom spsUtil quiet
#' @importFrom stats qnorm
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom rlang arg_match
#' @export
#'
SPEIChanges <- function(PPE.at.TS, nonstat.models = 1, criterion = "BIC"){
  if (!inherits(PPE.at.TS, c("TSaggreg", "matrix", "array"))) {
    stop("`PPE.at.TS` must be a matrix that is generated by using `TSaggreg()`.")
  }

  if (length(nonstat.models) != 1 || !is.numeric(nonstat.models) ||
      !(nonstat.models %in% 1:3)) {
    stop("`nonstat.models` must be a single integer value between 1 and 3.")
  }

  if (!is.numeric(PPE.at.TS) || anyNA(PPE.at.TS) ||
      ncol(PPE.at.TS) != 4 ) {
    stop("Physically impossible or missing values in PPE.at.TS.")}

  n <- length(PPE.at.TS[, 1])

  if (n < 480) {
    stop("Less than 10 years of P - PE records. We cannot proceed.")
  }
  if (n < 1440) {
    warning("Less than 30 years of P - PE records. Longer periods are highly recommended.")
  }

  if (length(PPE.at.TS[PPE.at.TS[, 2] < 1]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 2] > 12]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 1]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 2]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 3]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 4]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 5]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 6]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 7]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 8]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 9]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 10]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 11]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 12]) < 32) {
    stop("Column Month in PPE.at.TS is probably malformed.")
  }

  if (length(PPE.at.TS[PPE.at.TS[, 3] < 1]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 3] > 4]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 1]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 2]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 3]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 4]) < 96) {
    stop("Column quasiWeek in PPE.at.TS is probably malformed.")
  }

  # Print message and ensure newline so progress bar appears on the next line
  message("Fitting the GEV-based models to each quasi-weekly series...",
          appendLF = TRUE)
  # create single progress bar (max = 48)
  pb <- txtProgressBar(min = 0, max = 48, style = 3)

  years <- PPE.at.TS[,1]
  months <- PPE.at.TS[,2]
  data.week <- data.frame(matrix(NA, length(PPE.at.TS[, 1]), 8))
  GEV.parameters <- data.frame(matrix(NA, length(PPE.at.TS[, 1]), 5))
  data.week[,1:4] <- PPE.at.TS
  data.week <- data.week[order(data.week[,2],data.week[,3]),]
  GEV.parameters[,1:2] <- data.week[,2:3]
  month <- 1
  week <- 1
  Changes.Freq.Drought <- matrix(NA,48,8)

  for (a in 1:48) {
    # updating progress bar
    setTxtProgressBar(pb, a)
    PPE.week <- (data.week[which(data.week[, 2] == month &
                                   data.week[, 3] == week), 4])
    n.week <- length(PPE.week)
    quasiprob.ns <- matrix(NA,n.week,1)
    if (a > 1) {
      initial.row <- last.row + 1
      last.row <- initial.row + n.week - 1
    } else{
      initial.row <- 1
      last.row <- n.week
    }
    time <- as.matrix(seq(1:n.week))

    t.gev <- quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = NULL, shl = NULL,
                                    mulink = identity, siglink = identity, shlink = identity,
                                    muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                    method = "Nelder-Mead", maxit = 10000),
                            error = function(e) NULL
    ))
    models <- quiet(Fit.Models(PPE.week, time, nonstat.models, n.week, criterion = criterion))
    Changes.Freq.Drought[a, 3] <- models$best
    selected.model <- models$selected.model
    quasiprob <- (
      pevd(PPE.week, loc = t.gev$mle[1],
           scale = t.gev$mle[2],
           shape = t.gev$mle[3],
           type = c("GEV"), lower.tail = TRUE, log.p = FALSE)
    )
    quasiprob[quasiprob < 0.001351] <- 0.001351
    quasiprob[quasiprob > 0.998649] <- 0.998649
    data.week[initial.row:last.row, 6] <- quasiprob

    stat.PPE.exp <- qevd(c(0.5,0.159,0.067,0.023), loc = t.gev$mle[1],
                         scale = t.gev$mle[2],
                         shape = t.gev$mle[3],
                         type = c("GEV"), lower.tail = TRUE)
    Changes.Freq.Drought[a, 1] <- month
    Changes.Freq.Drought[a, 2] <- week
    if (Changes.Freq.Drought[a, 3]==1){
      quasiprob.ns <- quasiprob
      Changes.Freq.Drought[a, 4] <- round(stat.PPE.exp[1],2)
      Changes.Freq.Drought[a, 5] <- Changes.Freq.Drought[a, 4]
      Changes.Freq.Drought[a, 6:8] <- 0
    } else {
      for (i in 1:n.week){
        quasiprob.ns[i] <- pevd(PPE.week[i], loc = models$loc[i],
                                scale = models$scale[i],
                                shape = models$shape[i],
                                type = c("GEV"), lower.tail = TRUE, log.p = FALSE)}
      Changes.Freq.Drought[a, 4] <- round(stat.PPE.exp[1],2)
      Changes.Freq.Drought [a,5] <- round(qevd(0.5, loc = models$loc[n.week],
                                               scale = models$scale[n.week],
                                               shape = models$shape[n.week],
                                               type = c("GEV"), lower.tail = TRUE),2)
      actual.nsprob <- pevd(stat.PPE.exp, loc = models$loc[n.week], scale = models$scale[n.week], shape = models$shape[n.week],
                            type = c("GEV"), lower.tail = TRUE, log.p = FALSE)
      Changes.Freq.Drought [a,6] <- round(100 *(actual.nsprob[2]-0.159),2)

      Changes.Freq.Drought [a,7] <- round(100 *(actual.nsprob[3]-0.067),2)

      Changes.Freq.Drought [a,8] <- round(100 *(actual.nsprob[4]-0.023),2)
    }

    quasiprob.ns[quasiprob.ns < 0.001351] <- 0.001351
    quasiprob.ns[quasiprob.ns > 0.998649] <- 0.998649
    data.week[initial.row:last.row,7] <- quasiprob.ns

    GEV.parameters[initial.row:last.row, 3] <- models$loc
    GEV.parameters[initial.row:last.row, 4] <- models$scale
    GEV.parameters[initial.row:last.row, 5] <- models$shape

    week <- week + 1
    if (week == 5)
    {
      month <- month + 1
      week <- 1}
  }

  close(pb)
  data.week[,5] <- c(qnorm(data.week[,6], mean = 0, sd = 1))
  dry.values <- which(data.week[,5] <= 0)
  wet.values <- which(data.week[,5] > 0)
  data.week[dry.values,8] <- 100*round(data.week[dry.values,7]-data.week[dry.values,6],3)
  data.week[wet.values,8] <- "NoDrought"
  data.week <- data.week[order(data.week[,1]),]
  colnames(data.week) <- c(
    "Year",
    "Month",
    "quasiWeek",
    "PPE.at.TS",
    "SPEI",
    "Exp.Acum.Prob",
    "Actual.Acum.Prob",
    "ChangeDryFreq"
  )
  data.week[,4:7] <- round(data.week[,4:7],3)
  colnames(Changes.Freq.Drought) <- c(
    "Month",
    "quasiWeek",
    "Model",
    "StatNormalPPE",
    "NonStatNormalPPE",
    "ChangeMod",
    "ChangeSev",
    "ChangeExt"
  )
  colnames(GEV.parameters) <- c(
    "Month",
    "quasiWeek",
    "Location","Scale","Shape")

  Drought_Changes <- list(
    data.week = data.week,
    Changes.Freq.Drought = Changes.Freq.Drought,
    GEV.parameters = GEV.parameters
  )
  return(Drought_Changes)
}

#' Fit the nonstationary GEV models (SPEIChanges)
#'
#' @param PPE.week Numeric vector of (rainfall - PET)
#' @param time Numeric vector (same length as PPE.week)
#' @param nonstat.models single integer value indicating the number of nonstationary models to be fitted (from 1 to 3)
#' @param n.week Integer value indicating the length of PPE.week
#' @note This version uses the \CRANpkg{ismev} package with MLE estimation.
#' @noRd
#' @keywords Internal

Fit.Models <- function(PPE.week, time,nonstat.models,n.week,criterion="BIC") {
  # Ensure data are finite
  valid <- is.finite(PPE.week) & is.finite(time)
  PPE.week <- PPE.week[valid]
  time <- time[valid]
  criterion <- toupper(criterion)
  if (!criterion %in% c("AICC", "BIC")) {
    stop("`criterion` must be either 'AICc' or 'BIC'.")
  }
  # normalize to lowercase for later comparisons
  criterion_low <- tolower(criterion)
  # Fit candidate models
  if (nonstat.models == 1){
    t.gevs <- list(
      # Stationary
      t.gev = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = NULL, shl = NULL,
                                     mulink = identity, siglink = identity, shlink = identity,
                                     muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                     method = "Nelder-Mead", maxit = 10000),
                             error = function(e) NULL
      )),
      # Nonstationary in location only
      t.gev.ns10 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = 1, sigl = NULL, shl = NULL,
                                          mulink = identity, siglink = identity, shlink = identity,
                                          muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                          method = "Nelder-Mead", maxit = 10000),
                                  error = function(e) NULL
      )))} else if (nonstat.models == 2){
        t.gevs <- list(
          # Stationary
          t.gev = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = NULL, shl = NULL,
                                         mulink = identity, siglink = identity, shlink = identity,
                                         muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                         method = "Nelder-Mead", maxit = 10000),
                                 error = function(e) NULL
          )),
          # Nonstationary in location only
          t.gev.ns10 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = 1, sigl = NULL, shl = NULL,
                                              mulink = identity, siglink = identity, shlink = identity,
                                              muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                              method = "Nelder-Mead", maxit = 10000),
                                      error = function(e) NULL
          )),
          # Nonstationary in scale only
          t.gev.ns01 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = 1, shl = NULL,
                                              mulink = identity, siglink = identity, shlink = identity,
                                              muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                              method = "Nelder-Mead", maxit = 10000),
                                      error = function(e) NULL
          )))
      } else {
        t.gevs <- list(
          # Stationary
          t.gev = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = NULL, shl = NULL,
                                         mulink = identity, siglink = identity, shlink = identity,
                                         muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                         method = "Nelder-Mead", maxit = 10000),
                                 error = function(e) NULL
          )),
          # Nonstationary in location only
          t.gev.ns10 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = 1, sigl = NULL, shl = NULL,
                                              mulink = identity, siglink = identity, shlink = identity,
                                              muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                              method = "Nelder-Mead", maxit = 10000),
                                      error = function(e) NULL
          )),
          # Nonstationary in scale only
          t.gev.ns01 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = NULL, sigl = 1, shl = NULL,
                                              mulink = identity, siglink = identity, shlink = identity,
                                              muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                              method = "Nelder-Mead", maxit = 10000),
                                      error = function(e) NULL
          )),
          # Nonstationary in both location and scale
          t.gev.ns11 = quiet(tryCatch(gev.fit(PPE.week, ydat = as.matrix(time), mul = 1, sigl = 1, shl = NULL,
                                              mulink = identity, siglink = identity, shlink = identity,
                                              muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
                                              method = "Nelder-Mead", maxit = 10000),
                                      error = function(e) NULL
          ))
        )
      }

  # Extract log-likelihoods (NLLH = negative log-likelihood)
  ll <- sapply(t.gevs, function(x) if(is.null(x)) NA else -x$nllh)
  # Number of parameters (consistent with your previous definitions)
  k <- c(3, 4, 4, 5)
  if (criterion_low == "aicc"){
  # ---- Calculate AICc ------------------------------------------------------
  AICc <- (2*k - 2*ll) + (2*k*(k+1))/(n.week - k - 1)
  best <- which.min(AICc)} else {
  # ---- Calculate BIC -------------------------------------------------------
  BIC <- (k*log(n.week) - 2*ll)
  best <- which.min(BIC)}
  selected.model <- t.gevs[[best]]
  if (best == 1) {
    loc <- rep(as.numeric(selected.model$mle[1]),n.week)
    scale <- rep(as.numeric(selected.model$mle[2]),n.week)
    shape <- rep(as.numeric(selected.model$mle[3]),n.week)} else if (best == 2) {
      loc <- selected.model$mle[1] + selected.model$mle[2]*time
      scale <- rep(as.numeric(selected.model$mle[3]),n.week)
      shape <- rep(as.numeric(selected.model$mle[4]),n.week)} else if (best == 3) {
        loc <- rep(as.numeric(selected.model$mle[1]),n.week)
        scale <- selected.model$mle[2] + selected.model$mle[3]*time
        shape <- rep(as.numeric(selected.model$mle[4]),n.week)} else {
          loc <- selected.model$mle[1] + selected.model$mle[2]*time
          scale <- selected.model$mle[3] + selected.model$mle[4]*time
          shape <- rep(as.numeric(selected.model$mle[5]),n.week)}
  return(list(selected.model = selected.model, best = best, loc = loc, scale = scale, shape = shape))
  }
