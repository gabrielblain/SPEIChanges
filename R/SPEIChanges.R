#' Detect trends and quantify their effect on the probability of SPEI values occurring
#'
#' @param PPE.at.TS
#' A 4-column matrix generated as generated by `PPESaggreg()`. No other objects are accepted.
#'  * 1st column is years (YYYY),
#'  * 2nd is the months (1 to 12),
#'  * 3rd is the quasiWeeks (1 to 4),
#'  * and 4th is the difference between P and PE accumulated at a time scale.
#' @param nonstat.models
#' A single integer number indicating the number of increasingly complex candidate
#' nonstationary models to be considered in the drought assessments (from 1 to 5).
#' If 1, only stationary and nonstationary (linear) in location models are fitted (2 candidates).
#' If 2, a nonstationary (linear) in scale model is included (3 candidates).
#' If 3, a nonstationary (linear) in both location and scale models is included (4 candidates).
#' If 4, a nonstationary (polynomial 2nd degree) in location model is included (5 candidates).
#' If 5, a nonstationary (polynomial 2nd degree) in location and linear in scale model is included (6 candidates).
#' Default is 1.
#' @returns
#' A `list` object with:
#' \describe{
#'   \item{data.week}{The P - PE amounts, SPEI, cumulative probability of the SPEI values under the stationary
#'   approach, cumulative probability of the SPEI values under the non-stationary approach,
#'   and the changes in the frequency of below zero SPEI values caused by the changes in P - PE patterns.}
#'   \item{Changes.Freq.Drought}{The non-stationary  GEV-based model that best fits the P - PE series,
#'    the expected P - PE amounts describing normal conditions under both stationary and non-stationary
#'    approaches, and the changes in the frequency of moderate to extreme, severe to extreme and extreme drought events}
#'    \item{GEV.parameters}{Parameters of the best fitting GEV model (location, scale and shape) for each quasi-week.}
#'  }
#' @examplesIf interactive()
#' daily.PPE <- Campinas[, 11]
#' PPE.at.TS <- PPEaggreg(daily.PPE, start.date = "1995-01-01", TS = 4)
#' Changes_SPEI <- SPEIChanges(PPE.at.TS=PPE.at.TS, nonstat.models = 1)
#' @importFrom extRemes fevd pevd qevd
#' @importFrom spsUtil quiet
#' @importFrom stats qnorm
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @export
#'
SPEIChanges <- function(PPE.at.TS, nonstat.models = 1){
  if (!inherits(PPE.at.TS, c("TSaggreg", "matrix", "array"))) {
    stop("`PPE.at.TS` must be a matrix that is generated by using `TSaggreg()`.")
  }

  if (length(nonstat.models) != 1 || !is.numeric(nonstat.models) ||
      !(nonstat.models %in% 1:5)) {
    stop("`nonstat.models` must be a single integer value between 1 and 5.")
  }

  if (!is.numeric(PPE.at.TS) || anyNA(PPE.at.TS) ||
      ncol(PPE.at.TS) != 4 ) {
    stop("Physically impossible or missing values in PPE.at.TS.")}

  n <- length(PPE.at.TS[, 1])

  if (n < 480) {
    stop("Less than 10 years of P - PE records. We cannot proceed.")
  }
  if (n < 1440) {
    warning("Less than 30 years of P - PE records. Longer periods are highly recommended.")
  }

  if (length(PPE.at.TS[PPE.at.TS[, 2] < 1]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 2] > 12]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 1]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 2]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 3]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 4]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 5]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 6]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 7]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 8]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 9]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 10]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 11]) < 32 ||
      length(PPE.at.TS[PPE.at.TS[, 2] == 12]) < 32) {
    stop("Column Month in PPE.at.TS is probably malformed.")
  }

  if (length(PPE.at.TS[PPE.at.TS[, 3] < 1]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 3] > 4]) != 0 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 1]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 2]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 3]) < 96 ||
      length(PPE.at.TS[PPE.at.TS[, 3] == 4]) < 96) {
    stop("Column quasiWeek in PPE.at.TS is probably malformed.")
  }

  # Print message and ensure newline so progress bar appears on the next line
  message("Fitting the GEV-based models to each quasi-weekly series...",
          appendLF = TRUE)
  # create single progress bar (max = 48)
  pb <- txtProgressBar(min = 0, max = 48, style = 3)

  years <- PPE.at.TS[,1]
  months <- PPE.at.TS[,2]
  data.week <- data.frame(matrix(NA, length(PPE.at.TS[, 1]), 8))
  GEV.parameters <- data.frame(matrix(NA, length(PPE.at.TS[, 1]), 5))
  data.week[,1:4] <- PPE.at.TS
  data.week <- data.week[order(data.week[,2],data.week[,3]),]
  GEV.parameters[,1:2] <- data.week[,2:3]
  month <- 1
  week <- 1
  Changes.Freq.Drought <- matrix(NA,48,8)

  for (a in 1:48) {
    # updating progress bar
    setTxtProgressBar(pb, a)
    PPE.week <- (data.week[which(data.week[, 2] == month &
                                   data.week[, 3] == week), 4])
    n.week <- length(PPE.week)
    quasiprob.ns <- matrix(NA,n.week,1)
    if (a > 1) {
      initial.row <- last.row + 1
      last.row <- initial.row + n.week - 1
    } else{
      initial.row <- 1
      last.row <- n.week
    }
    time <- as.matrix(seq(1:n.week))

    t.gev <- quiet(tryCatch(summary(
      fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
      error = function(e) NULL
    )))
    models <- quiet(Fit.Models(PPE.week, time,nonstat.models,n.week))
    Changes.Freq.Drought[a, 3] <- models$best
    selected.model <- models$selected.model
    quasiprob <- (
      pevd(PPE.week, loc = t.gev$par[1],
           scale = t.gev$par[2],
           shape = t.gev$par[3],
           type = c("GEV"), lower.tail = TRUE, log.p = FALSE)
    )
    quasiprob[quasiprob < 0.001351] <- 0.001351
    quasiprob[quasiprob > 0.998649] <- 0.998649
    data.week[initial.row:last.row, 6] <- quasiprob

    stat.PPE.exp <- qevd(c(0.5,0.159,0.067,0.023), loc = t.gev$par[1],
                         scale = t.gev$par[2],
                         shape = t.gev$par[3],
                         type = c("GEV"), lower.tail = TRUE)
    Changes.Freq.Drought[a, 1] <- month
    Changes.Freq.Drought[a, 2] <- week
    if (Changes.Freq.Drought[a, 3]==1){
      quasiprob.ns <- quasiprob
      Changes.Freq.Drought[a, 4] <- round(stat.PPE.exp[1],2)
      Changes.Freq.Drought[a, 5] <- Changes.Freq.Drought[a, 4]
      Changes.Freq.Drought[a, 6:8] <- 0
    } else {
      #loc <- models$loc <- models$parms[1] + (models$parms[2]*time) + (models$parms[3]*(time^2))
      #sc <- models$parms[4] + (models$parms[5]*time)
      #sh <- models$parms[6]
      for (i in 1:n.week){
        quasiprob.ns[i] <- pevd(PPE.week[i], loc = models$loc[i],
                                scale = models$scale[i],
                                shape = models$shape[i],
                                type = c("GEV"), lower.tail = TRUE, log.p = FALSE)}
      Changes.Freq.Drought[a, 4] <- round(stat.PPE.exp[1],2)
      Changes.Freq.Drought [a,5] <- round(qevd(0.5, loc = models$loc[n.week],
                                               scale = models$scale[n.week],
                                               shape = models$shape[n.week],
                                               type = c("GEV"), lower.tail = TRUE),2)
      actual.nsprob <- pevd(stat.PPE.exp, loc = models$loc[n.week], scale = models$scale[n.week], shape = models$shape[n.week],
                            type = c("GEV"), lower.tail = TRUE, log.p = FALSE)
      Changes.Freq.Drought [a,6] <- round(100 *(actual.nsprob[2]-0.159),2)

      Changes.Freq.Drought [a,7] <- round(100 *(actual.nsprob[3]-0.067),2)

      Changes.Freq.Drought [a,8] <- round(100 *(actual.nsprob[4]-0.023),2)
    }

    quasiprob.ns[quasiprob.ns < 0.001351] <- 0.001351
    quasiprob.ns[quasiprob.ns > 0.998649] <- 0.998649
    data.week[initial.row:last.row,7] <- quasiprob.ns

    GEV.parameters[initial.row:last.row, 3] <- models$loc
    GEV.parameters[initial.row:last.row, 4] <- models$scale
    GEV.parameters[initial.row:last.row, 5] <- models$shape

    week <- week + 1
    if (week == 5)
    {
      month <- month + 1
      week <- 1}
  } #Aqui fecha o for

  close(pb)
  data.week[,5] <- c(qnorm(data.week[,6], mean = 0, sd = 1))
  dry.values <- which(data.week[,5] <= 0)
  wet.values <- which(data.week[,5] > 0)
  data.week[dry.values,8] <- 100*round(data.week[dry.values,7]-data.week[dry.values,6],3)
  data.week[wet.values,8] <- "NoDrought"
  data.week <- data.week[order(data.week[,1]),]
  colnames(data.week) <- c(
    "Year",
    "Month",
    "quasiWeek",
    "PPE.at.TS",
    "SPEI",
    "Exp.Acum.Prob",
    "Actual.Acum.Prob",
    "ChangeDryFreq"
  )
  data.week[,4:7] <- round(data.week[,4:7],3)
  colnames(Changes.Freq.Drought) <- c(
    "Month",
    "quasiWeek",
    "Model",
    "StatNormalPPE",
    "NonStatNormalPPE",
    "ChangeMod",
    "ChangeSev",
    "ChangeExt"
  )
  colnames(GEV.parameters) <- c(
    "Month",
    "quasiWeek",
    "Location","Scale","Shape")

  Drought_Changes <- list(
    data.week = data.week,
    Changes.Freq.Drought = Changes.Freq.Drought,
    GEV.parameters = GEV.parameters
  )
  return(Drought_Changes)
}

#' Fit the nonstationary GEV models (SPEIChanges)
#'
#' @param PPE.week Numeric vector of (rainfall - PET)
#' @param time Numeric vector (same length as PPE.week)
#' @param nonstat.models single integer value indicating the number of nonstationary models to be fitted (from 1 to 5)
#' @param n.week Integer value indicating the length of PPE.week
#' @note This version uses the \CRANpkg{extRemes} package with GMLE estimation.
#' @noRd
#' @keywords Internal

Fit.Models <- function(PPE.week, time,nonstat.models,n.week) {
  # Ensure data are finite
  valid <- is.finite(PPE.week) & is.finite(time)
  PPE.week <- PPE.week[valid]
  time <- time[valid]

  # Fit candidate models
  if (nonstat.models == 1){
    t.gevs <- list(
      # Stationary
      t.gev = summary(tryCatch(
        fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
        error = function(e) NULL
      )),
      # Nonstationary in location only
      t.gev.ns10 = summary(tryCatch(
        fevd(PPE.week, method = "GMLE", type = "GEV",
             location.fun = ~ time, use.phi = TRUE),
        error = function(e) NULL
      )))} else if (nonstat.models == 2){
        t.gevs <- list(
          # Stationary
          t.gev = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
            error = function(e) NULL
          )),
          # Nonstationary in location only
          t.gev.ns10 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),
          # Nonstationary in scale only
          t.gev.ns01 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )))
      } else if (nonstat.models == 3){
        t.gevs <- list(
          # Stationary
          t.gev = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in location only
          t.gev.ns10 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in scale only
          t.gev.ns01 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in both location and scale
          t.gev.ns11 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time,
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          ))
        )
      } else if (nonstat.models == 4){
        t.gevs <- list(
          # Stationary
          t.gev = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in location only
          t.gev.ns10 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in scale only
          t.gev.ns01 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in both location and scale
          t.gev.ns11 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time,
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),
          # polynomial degree two in location only
          t.gev.ns20 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time + I(time^2),
                 use.phi = TRUE),
            error = function(e) NULL
          ))
        )
      } else{
        t.gevs <- list(
          # Stationary
          t.gev = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV", use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in location only
          t.gev.ns10 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in scale only
          t.gev.ns01 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),

          # Nonstationary in both location and scale
          t.gev.ns11 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time,
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          )),
          # polynomial degree two in location only
          t.gev.ns20 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time + I(time^2),
                 use.phi = TRUE),
            error = function(e) NULL
          )),
          # polynomial degree two in location and linear in scale
          t.gev.ns21 = summary(tryCatch(
            fevd(PPE.week, method = "GMLE", type = "GEV",
                 location.fun = ~ time + I(time^2),
                 scale.fun = ~ time, use.phi = TRUE),
            error = function(e) NULL
          ))
        )
      }
  # Select best model based on AICc
  aics <- c(
    t.gevs$t.gev$AIC,
    t.gevs$t.gev.ns10$AIC,
    t.gevs$t.gev.ns01$AIC,
    t.gevs$t.gev.ns11$AIC,
    t.gevs$t.gev.ns20$AIC,
    t.gevs$t.gev.ns21$AIC
  )

  # Find the index of the minimum AIC
  best <- which.min(aics)
  selected.model <- t.gevs[[best]]
  if (best == 1)
  {loc <- rep(as.numeric(selected.model$par[1]),n.week)
  scale <- rep(as.numeric(selected.model$par[2]),n.week)
  shape <- rep(as.numeric(selected.model$par[3]),n.week)}
  #parms <- c(selected.model$par[1],0,0,selected.model$par[2],0,selected.model$par[3])}
  else if (best == 2)
  {loc <- selected.model$par[1] + selected.model$par[2]*time
  scale <- rep(as.numeric(selected.model$par[3]),n.week)
  shape <- rep(as.numeric(selected.model$par[4]),n.week)}
  #parms <- c(selected.model$par[1],selected.model$par[2],0,selected.model$par[3],0,selected.model$par[4])}
  else if (best == 3)
  {loc <- rep(as.numeric(selected.model$par[1]),n.week)
  scale <- exp(selected.model$par[2] + selected.model$par[3]*time)
  shape <- rep(as.numeric(selected.model$par[4]),n.week)}
  #parms <- c(selected.model$par[1],0,0,selected.model$par[2],selected.model$par[3],0,selected.model$par[4])}
  else if (best == 4)
  {loc <- selected.model$par[1] + selected.model$par[2]*time
  scale <- exp(selected.model$par[3] + selected.model$par[4]*time)
  shape <- rep(as.numeric(selected.model$par[5]),n.week)}
  #parms <- c(selected.model$par[1],selected.model$par[2],0,selected.model$par[3],selected.model$par[4],selected.model$par[5])}
  else if (best == 5)
  {loc <- selected.model$par[1] + selected.model$par[2]*time + selected.model$par[3]*time^2
  scale <- rep(as.numeric(selected.model$par[4]),n.week)
  shape <- rep(as.numeric(selected.model$par[5]),n.week)}
  #parms <- c(selected.model$par[1],selected.model$par[2],selected.model$par[3],selected.model$par[4],0,selected.model$par[5])}
  else
  {loc <- selected.model$par[1] + selected.model$par[2]*time + selected.model$par[3]*time^2
  scale <- exp(selected.model$par[4] + selected.model$par[5]*time)
  shape <- rep(as.numeric(selected.model$par[6]),n.week)}
  #parms <- c(selected.model$par[1],selected.model$par[2],selected.model$par[3],selected.model$par[4],selected.model$par[5],selected.model$par[6])}

  return(list(selected.model = selected.model, best = best, loc = loc, scale = scale, shape = shape))
}
